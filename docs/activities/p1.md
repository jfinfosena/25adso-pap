# Actividad: Ejemplo de FastAPI con Tres Entidades

Este documento describe una aplicación FastAPI modular con tres entidades: **User**, **Product** y **Order**. La aplicación utiliza **FastAPI**, **SQLAlchemy** para la gestión de bases de datos y **Pydantic** para la validación de datos. Está estructurada de forma modular para facilitar la escalabilidad y el mantenimiento.

## Estructura del Proyecto

La aplicación sigue una estructura basada en tipo de archivo, adecuada para proyectos pequeños o medianos:

```
project/
├── src/
│   ├── __init__.py
│   ├── main.py           # Inicializa la app FastAPI
│   ├── database.py       # Configuración de la base de datos
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── users.py      # Rutas para usuarios
│   │   ├── products.py   # Rutas para productos
│   │   ├── orders.py     # Rutas para órdenes
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── user.py       # Esquemas Pydantic para usuarios
│   │   ├── product.py    # Esquemas Pydantic para productos
│   │   ├── order.py      # Esquemas Pydantic para órdenes
│   ├── models/
│   │   ├── __init__.py
│   │   ├── user.py       # Modelos SQLAlchemy para usuarios
│   │   ├── product.py    # Modelos SQLAlchemy para productos
│   │   ├── order.py      # Modelos SQLAlchemy para órdenes
├── requirements.txt      # Dependencias del proyecto
```

## Requisitos

El archivo `requirements.txt` lista las dependencias necesarias:

```text
fastapi[standard]
sqlalchemy
pydantic
```

Instala las dependencias con:

```bash
pip install -r requirements.txt
```

## Configuración de la Base de Datos

El archivo `src/database.py` configura una base de datos SQLite y proporciona una función para obtener sesiones de base de datos:

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

## Modelos SQLAlchemy

Los modelos definen las tablas de la base de datos usando SQLAlchemy.

### Modelo User (`src/models/user.py`)

```python
from sqlalchemy import Column, Integer, String
from src.database import Base

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
```

### Modelo Product (`src/models/product.py`)

```python
from sqlalchemy import Column, Integer, String, Float
from src.database import Base

class Product(Base):
    __tablename__ = "products"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, index=True)
    price = Column(Float)
```

### Modelo Order (`src/models/order.py`)

```python
from sqlalchemy import Column, Integer, ForeignKey
from sqlalchemy.orm import relationship
from src.database import Base

class Order(Base):
    __tablename__ = "orders"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    product_id = Column(Integer, ForeignKey("products.id"))
    
    user = relationship("User")
    product = relationship("Product")
```

## Esquemas Pydantic

Los esquemas Pydantic definen la validación de datos para las solicitudes y respuestas de la API.

### Esquema User (`src/schemas/user.py`)

```python
from pydantic import BaseModel

class UserCreate(BaseModel):
    username: str
    email: str

class User(BaseModel):
    id: int
    username: str
    email: str

    class Config:
        from_attributes = True
```

### Esquema Product (`src/schemas/product.py`)

```python
from pydantic import BaseModel

class ProductCreate(BaseModel):
    name: str
    price: float

class Product(BaseModel):
    id: int
    name: str
    price: float

    class Config:
        from_attributes = True
```

### Esquema Order (`src/schemas/order.py`)

```python
from pydantic import BaseModel

class OrderCreate(BaseModel):
    user_id: int
    product_id: int

class Order(BaseModel):
    id: int
    user_id: int
    product_id: int

    class Config:
        from_attributes = True
```

## Rutas (Routers)

Las rutas definen los endpoints de la API usando `APIRouter` para cada entidad.

### Rutas de Usuarios (`src/routers/users.py`)

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from src.database import get_db
from src.models.user import User as UserModel
from src.schemas.user import User, UserCreate

router = APIRouter(tags=["users"])

@router.post("/users/", response_model=User)
async def create_user(user: UserCreate, db: Session = Depends(get_db)):
    db_user = UserModel(**user.dict())
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

@router.get("/users/{user_id}", response_model=User)
async def read_user(user_id: int, db: Session = Depends(get_db)):
    db_user = db.query(UserModel).filter(UserModel.id == user_id).first()
    if db_user is None:
        raise HTTPException(status_code=404, detail="User not found")
    return db_user
```

### Rutas de Productos (`src/routers/products.py`)

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from src.database import get_db
from src.models.product import Product as ProductModel
from src.schemas.product import Product, ProductCreate

router = APIRouter(tags=["products"])

@router.post("/products/", response_model=Product)
async def create_product(product: ProductCreate, db: Session = Depends(get_db)):
    db_product = ProductModel(**product.dict())
    db.add(db_product)
    db.commit()
    db.refresh(db_product)
    return db_product

@router.get("/products/{product_id}", response_model=Product)
async def read_product(product_id: int, db: Session = Depends(get_db)):
    db_product = db.query(ProductModel).filter(ProductModel.id == product_id).first()
    if db_product is None:
        raise HTTPException(status_code=404, detail="Product not found")
    return db_product
```

### Rutas de Órdenes (`src/routers/orders.py`)

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from src.database import get_db
from src.models.order import Order as OrderModel
from src.schemas.order import Order, OrderCreate

router = APIRouter(tags=["orders"])

@router.post("/orders/", response_model=Order)
async def create_order(order: OrderCreate, db: Session = Depends(get_db)):
    db_order = OrderModel(**order.dict())
    db.add(db_order)
    db.commit()
    db.refresh(db_order)
    return db_order

@router.get("/orders/{order_id}", response_model=Order)
async def read_order(order_id: int, db: Session = Depends(get_db)):
    db_order = db.query(OrderModel).filter(OrderModel.id == order_id).first()
    if db_order is None:
        raise HTTPException(status_code=404, detail="Order not found")
    return db_order
```

## Aplicación Principal (`src/main.py`)

El archivo principal inicializa la aplicación FastAPI e incluye los routers:

```python
from fastapi import FastAPI
from src.database import Base, engine
from src.routers import users, products, orders

app = FastAPI()

# Crear las tablas en la base de datos
Base.metadata.create_all(bind=engine)

# Incluir los routers
app.include_router(users.router, prefix="/api")
app.include_router(products.router, prefix="/api")
app.include_router(orders.router, prefix="/api")

@app.get("/")
async def root():
    return {"message": "Welcome to FastAPI with 3 entities"}
```

## Ejecución de la Aplicación FastAPI

1. **Crear un entorno virtual**:

```bash
python -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
```

2. **Instalar dependencias**:

```bash
pip install -r requirements.txt
```

3. **Ejecutar la aplicación**:

```bash
fastapi dev src/main.py
```

4. **Probar la API**:
   - Abre `http://127.0.0.1:8000/docs` para acceder a la interfaz de Swagger UI.
   - Ejemplo de endpoints:
     - **POST** `/api/users/` con `{"username": "john", "email": "john@example.com"}`
     - **POST** `/api/products/` con `{"name": "Laptop", "price": 999.99}`
     - **POST** `/api/orders/` con `{"user_id": 1, "product_id": 1}`
     - **GET** `/api/users/1`, `/api/products/1`, `/api/orders/1`

## Notas

- **Base de datos**: Usa SQLite (`test.db`) para simplicidad. Cambia `DATABASE_URL` en `database.py` para usar PostgreSQL, MySQL, etc.
- **Modularidad**: Cada entidad tiene su propio módulo (modelos, esquemas, rutas), lo que facilita la escalabilidad.
- **Validación**: Pydantic valida los datos de entrada.
- **Relaciones**: El modelo `Order` incluye claves foráneas para relacionar con `User` y `Product`.


## Actividad de consulta 

### Pregunta 1 (Grupo 1): 

¿Para qué sirven las siguientes dependencias: fastapi[standard], sqlalchemy y pydantic?

### Pregunta 2 (Grupo 2): 

Explica cómo se definen las tablas de la base de datos usando modelos SQLAlchemy en el contexto de FastAPI.

### Pregunta 3 (Grupo 3): 

¿Cómo definen los esquemas Pydantic la validación de datos en las solicitudes y respuestas de una API?

### Pregunta 4 (Grupo 4): 

Explica qué es APIRouter en FastAPI y cómo se utiliza para definir endpoints en una API.

### Pregunta 5 (Grupo 5): 

Explica qué son los módulos en FastAPI y cuál es su propósito principal en la organización del código. Describe cómo el archivo __init__.py contribuye a la estructura modular de un proyecto FastAPI.

### Pregunta 6 (Grupo 6): 
¿Cuáles son las principales ventajas de implementar la modularización en un proyecto FastAPI?


