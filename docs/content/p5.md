# Módulos en FastAPI


En FastAPI, los **módulos** son una forma de organizar y estructurar el código de manera eficiente, promoviendo la modularidad, reutilización y escalabilidad. Esto se logra principalmente mediante el uso de **APIRouter** y la organización de archivos en un proyecto. A continuación, te explico cómo se manejan los módulos en FastAPI y cómo estructurar un proyecto modular, basado en las mejores prácticas y la información disponible:

### 1. **Uso de APIRouter para modularizar rutas**
FastAPI proporciona la clase `APIRouter` para dividir las rutas de la API en módulos más pequeños y manejables. Esto permite separar la lógica de las rutas en diferentes archivos, lo que facilita el mantenimiento y la colaboración en equipo.[](https://www.youtube.com/watch?v=iintDoK1aH4)[](https://certidevs.com/tutorial-fastapi-apirouter)

#### Ejemplo básico de modularización con APIRouter:

1. **Crear un archivo para un módulo específico** (por ejemplo, `routers/users.py`):
   ```python
   from fastapi import APIRouter

   router = APIRouter()

   @router.get("/users/")
   async def read_users():
       return [{"username": "user1"}, {"username": "user2"}]

   @router.post("/users/")
   async def create_user(user: dict):
       return {"message": "User created", "user": user}
   ```

2. **Integrar el módulo en el archivo principal** (por ejemplo, `main.py`):
   ```python
   from fastapi import FastAPI
   from routers import users

   app = FastAPI()

   # Incluir el router de users
   app.include_router(users.router, prefix="/api", tags=["users"])

   @app.get("/")
   async def root():
       return {"message": "Welcome to FastAPI"}
   ```

   - **`prefix`**: Define un prefijo para todas las rutas del módulo (por ejemplo, `/api/users/`).
   - **`tags`**: Agrupa las rutas en la documentación automática (Swagger UI) para mejor organización.

3. **Ejecutar la aplicación**:
   ```bash
   fastapi dev main.py
   ```
   Esto permite que las rutas definidas en `users.py` estén disponibles bajo el prefijo `/api/users/`.

### 2. **Estructuración de proyectos FastAPI**
Existen dos enfoques principales para estructurar proyectos en FastAPI: **por tipo de archivo** y **por funcionalidad de módulo**. Cada uno es adecuado según el tamaño y la arquitectura del proyecto.[](https://codigoencasa.com/como-estructurar-tus-proyectos-fastapi/)[](https://nuriavazquez.dev/blog/backend_fastapi_estructuras/)

#### a) **Estructura basada en tipo de archivo**
Ideal para microservicios o proyectos pequeños. Los archivos se organizan según su propósito (rutas, modelos, esquemas, etc.). Ejemplo:

```
project/
├── app/
│   ├── __init__.py
│   ├── main.py           # Inicializa la app FastAPI
│   ├── dependencies.py   # Dependencias globales
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── users.py      # Rutas relacionadas con usuarios
│   │   ├── items.py      # Rutas relacionadas con ítems
│   ├── crud/
│   │   ├── __init__.py
│   │   ├── user.py       # Operaciones CRUD para usuarios
│   │   ├── item.py       # Operaciones CRUD para ítems
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── user.py       # Esquemas Pydantic para usuarios
│   │   ├── item.py       # Esquemas Pydantic para ítems
│   ├── models/
│   │   ├── __init__.py
│   │   ├── user.py       # Modelos SQLAlchemy para usuarios
│   │   ├── item.py       # Modelos SQLAlchemy para ítems
│   ├── external_services/
│   │   ├── __init__.py
│   │   ├── email.py      # Servicios externos (ej. envío de correos)
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── authentication.py
│   │   ├── validation.py
├── tests/
│   ├── __init__.py
│   ├── test_users.py
│   ├── test_items.py
├── requirements.txt
├── .gitignore
└── README.md
```

- **Ventajas**:

    - Clara separación por tipo de archivo (rutas, modelos, esquemas).
    - Ideal para proyectos con un enfoque claro y limitado en funcionalidad.
    - Fácil de entender para desarrolladores familiarizados con FastAPI.

#### b) **Estructura basada en funcionalidad de módulo**
Recomendada para proyectos monolíticos más grandes, donde cada módulo agrupa toda la lógica relacionada con una funcionalidad específica (por ejemplo, autenticación, publicaciones, etc.). Ejemplo:

```
project/
├── src/
│   ├── auth/
│   │   ├── __init__.py
│   │   ├── router.py       # Rutas de autenticación
│   │   ├── schemas.py      # Esquemas Pydantic
│   │   ├── models.py       # Modelos de base de datos
│   │   ├── dependencies.py # Dependencias específicas
│   │   ├── service.py      # Lógica de negocio
│   │   ├── config.py       # Configuraciones locales
│   │   ├── constants.py    # Constantes específicas
│   │   ├── exceptions.py   # Excepciones específicas
│   │   ├── utils.py        # Utilidades no relacionadas con la lógica
│   ├── posts/
│   │   ├── __init__.py
│   │   ├── router.py
│   │   ├── schemas.py
│   │   ├── models.py
│   │   ├── dependencies.py
│   │   ├── service.py
│   │   ├── config.py
│   │   ├── constants.py
│   │   ├── exceptions.py
│   │   ├── utils.py
│   ├── config.py           # Configuraciones globales
│   ├── models.py          # Modelos globales
│   ├── exceptions.py      # Excepciones globales
│   ├── database.py        # Conexión a la base de datos
│   ├── main.py            # Inicializa la app FastAPI
├── tests/
│   ├── auth/
│   ├── posts/
├── templates/
│   ├── index.html
├── requirements/
│   ├── base.txt
│   ├── dev.txt
│   ├── prod.txt
├── .env
├── .gitignore
├── logging.ini
└── alembic.ini
```

- **Ventajas**:

    - Agrupa toda la lógica relacionada con una funcionalidad en un solo lugar.
    - Mejora la mantenibilidad en proyectos grandes.
    - Facilita la colaboración en equipos al evitar conflictos entre módulos.

### 3. **Módulos importantes instalados con FastAPI**
Al instalar FastAPI (`pip install "fastapi[standard]"`), se incluyen módulos clave que potencian su funcionalidad:[](https://www.desarrollolibre.net/blog/python/curso-primeros-pasos-con-fastapi)[](https://www.desarrollolibre.net/libros/libro-primeros-pasos-con-fastapi)

- **Pydantic**: Permite la creación de modelos para validación de datos y serialización. Se usa para definir esquemas (schemas) que validan los datos de entrada y salida.
  ```python
  from pydantic import BaseModel

  class User(BaseModel):
      username: str
      email: str
  ```

- **Starlette**: Framework ASGI ligero que proporciona la base para servicios web asíncronos en FastAPI.

Además, puedes extender FastAPI con otros módulos como:
- **SQLAlchemy**: Para manejar bases de datos relacionales.[](https://www.desarrollolibre.net/blog/python/curso-primeros-pasos-con-fastapi)
- **Jinja2**: Para motores de plantillas si necesitas renderizar páginas web.
- **python-jose** o **passlib**: Para autenticación y manejo de tokens.

### 4. **Principios clave para la modularización**
Para mantener un proyecto FastAPI modular y escalable, sigue estas prácticas:[](https://codigoencasa.com/como-estructurar-tus-proyectos-fastapi/)[](https://github.com/brnooliveira/fastapi-modular-pattern)
- **Separación de intereses**: Divide la lógica de negocio, rutas, modelos y esquemas en módulos separados.
- **Inyección de dependencias**: Usa `fastapi.Depends` para desacoplar componentes y mejorar la testabilidad.
  ```python
  from fastapi import Depends, FastAPI

  async def get_current_user():
      return {"user_id": 1}

  @app.get("/profile")
  async def read_profile(user=Depends(get_current_user)):
      return user
  ```
- **Testabilidad**: Estructura el código para facilitar pruebas unitarias, usando mocks y dependencias.
- **Reutilización**: Crea módulos reutilizables para lógica común (por ejemplo, autenticación, validaciones).

### 5. **Ejemplo práctico: Módulo de usuarios con base de datos**
Supongamos que quieres crear un módulo para gestionar usuarios con FastAPI, SQLAlchemy y Pydantic. Aquí un ejemplo simplificado:

#### Estructura:
```
project/
├── src/
│   ├── users/
│   │   ├── __init__.py
│   │   ├── router.py
│   │   ├── schemas.py
│   │   ├── models.py
│   ├── database.py
│   ├── main.py
├── requirements.txt
```

#### Código:
- **`src/users/schemas.py`** (esquemas Pydantic):
  ```python
  from pydantic import BaseModel

  class UserCreate(BaseModel):
      username: str
      email: str

  class User(BaseModel):
      id: int
      username: str
      email: str

      class Config:
          orm_mode = True
  ```

- **`src/users/models.py`** (modelos SQLAlchemy):
  ```python
  from sqlalchemy import Column, Integer, String
  from src.database import Base

  class User(Base):
      __tablename__ = "users"
      id = Column(Integer, primary_key=True, index=True)
      username = Column(String, unique=True, index=True)
      email = Column(String, unique=True, index=True)
  ```

- **`src/users/router.py`** (rutas):
  ```python
  from fastapi import APIRouter, Depends
  from sqlalchemy.orm import Session
  from src.database import get_db
  from .schemas import User, UserCreate
  from .models import User as UserModel

  router = APIRouter()

  @router.post("/users/", response_model=User)
  async def create_user(user: UserCreate, db: Session = Depends(get_db)):
      db_user = UserModel(**user.dict())
      db.add(db_user)
      db.commit()
      db.refresh(db_user)
      return db_user
  ```

- **`src/database.py`** (configuración de la base de datos):
  ```python
  from sqlalchemy import create_engine
  from sqlalchemy.ext.declarative import declarative_base
  from sqlalchemy.orm import sessionmaker

  DATABASE_URL = "sqlite:///./test.db"
  engine = create_engine(DATABASE_URL)
  SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
  Base = declarative_base()

  def get_db():
      db = SessionLocal()
      try:
          yield db
      finally:
          db.close()
  ```

- **`src/main.py`** (app principal):
  ```python
  from fastapi import FastAPI
  from src.users.router import router as users_router
  from src.database import Base, engine

  app = FastAPI()

  # Crear las tablas en la base de datos
  Base.metadata.create_all(bind=engine)

  # Incluir el router de usuarios
  app.include_router(users_router, prefix="/api", tags=["users"])
  ```

#### Instalación de dependencias:
```bash
pip install "fastapi[standard]" sqlalchemy
```

#### Ejecución:
```bash
fastapi dev main.py
```
Accede a `http://127.0.0.1:8000/docs` para probar la API con Swagger UI.

### 6. **Ventajas de la modularización en FastAPI**
- **Escalabilidad**: Facilita agregar nuevas funcionalidades sin modificar el núcleo de la aplicación.
- **Mantenibilidad**: Código organizado y fácil de entender.
- **Colaboración**: Equipos pueden trabajar en módulos separados sin conflictos.
- **Reutilización**: Componentes como esquemas o dependencias pueden compartirse entre módulos.

