# Clase 7: API de Blog

Este documento describe una API basada en FastAPI para un blog, con una estructura modular que maneja usuarios, publicaciones y comentarios, utilizando SQLite como base de datos.

## Descripción del Proyecto

La API de Blog es una API RESTful construida con FastAPI, organizada en módulos para facilitar su mantenimiento. Utiliza SQLite para el almacenamiento de datos y Pydantic para la validación. La API soporta operaciones CRUD para usuarios, publicaciones y comentarios.

## Estructura del Proyecto

El proyecto está organizado de la siguiente manera:

```
project/
├── routers/
│   ├── __init__.py
│   ├── users.py
│   ├── posts.py
│   └── comments.py
├── main.py
├── database.py
└── models.py
```

### Descripción de los Archivos

- **main.py**: Punto de entrada, inicializa FastAPI y conecta los routers.
- **database.py**: Gestiona la conexión y configuración de la base de datos SQLite.
- **models.py**: Define los modelos de Pydantic para la validación de datos.
- **routers/**: Contiene las definiciones de los endpoints para usuarios, publicaciones y comentarios.

## Código

A continuación, se presenta el código fuente completo de cada archivo.

### main.py

```python
from fastapi import FastAPI
from routers import users, posts, comments
from database import init_db

app = FastAPI(title="Blog API")

# Initialize database
init_db()

# Include routers
app.include_router(users.router)
app.include_router(posts.router)
app.include_router(comments.router)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### database.py

```python
import sqlite3
from contextlib import contextmanager

def get_db():
    conn = sqlite3.connect("blog.db")
    conn.row_factory = sqlite3.Row
    try:
        yield conn
    finally:
        conn.close()

def init_db():
    with sqlite3.connect("blog.db") as conn:
        cursor = conn.cursor()
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                username TEXT UNIQUE NOT NULL,
                email TEXT UNIQUE NOT NULL
            )
        """)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS posts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                content TEXT NOT NULL,
                user_id INTEGER,
                created_at TEXT,
                FOREIGN KEY (user_id) REFERENCES users (id)
            )
        """)
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS comments (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                content TEXT NOT NULL,
                user_id INTEGER,
                post_id INTEGER,
                created_at TEXT,
                FOREIGN KEY (user_id) REFERENCES users (id),
                FOREIGN KEY (post_id) REFERENCES posts (id)
            )
        """)
        conn.commit()
```

### models.py

```python
from pydantic import BaseModel
from typing import List, Optional

class UserCreate(BaseModel):
    username: str
    email: str

class UserResponse(BaseModel):
    id: int
    username: str
    email: str

class PostCreate(BaseModel):
    title: str
    content: str

class PostResponse(BaseModel):
    id: int
    title: str
    content: str
    user_id: int
    created_at: str

class CommentCreate(BaseModel):
    content: str

class CommentResponse(BaseModel):
    id: int
    content: str
    user_id: int
    post_id: int
    created_at: str
```

### routers/users.py

```python
from fastapi import APIRouter, HTTPException, Depends
from typing import List
import sqlite3
from database import get_db
from models import UserCreate, UserResponse

router = APIRouter(prefix="/users", tags=["users"])

@router.post("/", response_model=UserResponse)
def create_user(user: UserCreate, db: sqlite3.Connection = Depends(get_db)):
    cursor = db.cursor()
    try:
        cursor.execute(
            "INSERT INTO users (username, email) VALUES (?, ?)",
            (user.username, user.email)
        )
        db.commit()
        return {"id": cursor.lastrowid, **user.dict()}
    except sqlite3.IntegrityError:
        raise HTTPException(status_code=400, detail="Username or email already exists")

@router.get("/", response_model=List[UserResponse])
def get_users(db: sqlite3.Connection = Depends(get_db)):
    cursor = db.cursor()
    cursor.execute("SELECT * FROM users")
    return [{"id": row["id"], "username": row["username"], "email": row["email"]} for row in cursor.fetchall()]

@router.get("/{user_id}", response_model=UserResponse)
def get_user(user_id: int, db: sqlite3.Connection = Depends(get_db)):
    cursor = db.cursor()
    cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
    user = cursor.fetchone()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return {"id": user["id"], "username": user["username"], "email": user["email"]}
```

### routers/posts.py

```python
from fastapi import APIRouter, HTTPException, Depends
from typing import List
from datetime import datetime
import sqlite3
from database import get_db
from models import PostCreate, PostResponse

router = APIRouter(prefix="/posts", tags=["posts"])

@router.post("/", response_model=PostResponse)
def create_post(post: PostCreate, user_id: int, db: sqlite3.Connection = Depends(get_db)):
    cursor = db.cursor()
    cursor.execute("SELECT id FROM users WHERE id = ?", (user_id,))
    if not cursor.fetchone():
        raise HTTPException(status_code=404, detail="User not found")
    
    created_at = datetime.utcnow().isoformat()
    cursor.execute(
        "INSERT INTO posts (title, content, user_id, created_at) VALUES (?, ?, ?, ?)",
        (post.title, post.content, user_id, created_at)
    )
    db.commit()
    return {"id": cursor.lastrowid, **post.dict(), "user_id": user_id, "created_at": created_at}

@router.get("/", response_model=List[PostResponse])
def get_posts(db: sqlite3.Connection = Depends(get_db)):
    cursor = db.cursor()
    cursor.execute("SELECT * FROM posts")
    return [{"id": row["id"], "title": row["title"], "content": row["content"], 
             "user_id": row["user_id"], "created_at": row["created_at"]} for row in cursor.fetchall()]

@router.get("/{post_id}", response_model=PostResponse)
def get_post(post_id: int, db: sqlite3.Connection = Depends(get_db)):
    cursor = db.cursor()
    cursor.execute("SELECT * FROM posts WHERE id = ?", (post_id,))
    post = cursor.fetchone()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")
    return {"id": post["id"], "title": post["title"], "content": post["content"], 
            "user_id": post["user_id"], "created_at": post["created_at"]}
```

### routers/comments.py

```python
from fastapi import APIRouter, HTTPException, Depends
from typing import List
from datetime import datetime
import sqlite3
from database import get_db
from models import CommentCreate, CommentResponse

router = APIRouter(prefix="/posts/{post_id}/comments", tags=["comments"])

@router.post("/", response_model=CommentResponse)
def create_comment(post_id: int, comment: CommentCreate, user_id: int, db: sqlite3.Connection = Depends(get_db)):
    cursor = db.cursor()
    cursor.execute("SELECT id FROM posts WHERE id = ?", (post_id,))
    if not cursor.fetchone():
        raise HTTPException(status_code=404, detail="Post not found")
    
    cursor.execute("SELECT id FROM users WHERE id = ?", (user_id,))
    if not cursor.fetchone():
        raise HTTPException(status_code=404, detail="User not found")
    
    created_at = datetime.utcnow().isoformat()
    cursor.execute(
        "INSERT INTO comments (content, user_id, post_id, created_at) VALUES (?, ?, ?, ?)",
        (comment.content, user_id, post_id, created_at)
    )
    db.commit()
    return {"id": cursor.lastrowid, "content": comment.content, "user_id": user_id, 
            "post_id": post_id, "created_at": created_at}

@router.get("/", response_model=List[CommentResponse])
def get_comments(post_id: int, db: sqlite3.Connection = Depends(get_db)):
    cursor = db.cursor()
    cursor.execute("SELECT * FROM comments WHERE post_id = ?", (post_id,))
    return [{"id": row["id"], "content": row["content"], "user_id": row["user_id"], 
             "post_id": row["post_id"], "created_at": row["created_at"]} for row in cursor.fetchall()]
```

## Instrucciones de Configuración

1. **Crear la estructura del proyecto** como se mostró anteriormente.
2. **Instalar las dependencias**:
   ```bash
   pip install fastapi uvicorn
   ```
3. **Crear un archivo `__init__.py`** vacío en el directorio `routers/`.
4. **Ejecutar el servidor** desde el directorio `project/`:
   ```bash
   uvicorn main:app --reload
   ```
5. **Acceder a la documentación interactiva** en `http://localhost:8000/docs`.

## Endpoints de la API

La API proporciona los siguientes endpoints:

### Usuarios
- **POST /users/**: Crear un nuevo usuario.
  - Cuerpo: `{"username": "string", "email": "string"}`
  - Respuesta: `{"id": int, "username": "string", "email": "string"}`
- **GET /users/**: Listar todos los usuarios.
  - Respuesta: `[{"id": int, "username": "string", "email": "string"}, ...]`
- **GET /users/{user_id}**: Obtener un usuario específico por ID.
  - Respuesta: `{"id": int, "username": "string", "email": "string"}`

### Publicaciones
- **POST /posts/**: Crear una nueva publicación (requiere el parámetro `user_id` en la query).
  - Query: `user_id=int`
  - Cuerpo: `{"title": "string", "content": "string"}`
  - Respuesta: `{"id": int, "title": "string", "content": "string", "user_id": int, "created_at": "string"}`
- **GET /posts/**: Listar todas las publicaciones.
  - Respuesta: `[{"id": int, "title": "string", "content": "string", "user_id": int, "created_at": "string"}, ...]`
- **GET /posts/{post_id}**: Obtener una publicación específica por ID.
  - Respuesta: `{"id": int, "title": "string", "content": "string", "user_id": int, "created_at": "string"}`

### Comentarios
- **POST /posts/{post_id}/comments/**: Crear un nuevo comentario (requiere el parámetro `user_id` en la query).
  - Query: `user_id=int`
  - Cuerpo: `{"content": "string"}`
  - Respuesta: `{"id": int, "content": "string", "user_id": int, "post_id": int, "created_at": "string"}`
- **GET /posts/{post_id}/comments/**: Listar todos los comentarios de una publicación específica.
  - Respuesta: `[{"id": int, "content": "string", "user_id": int, "post_id": int, "created_at": "string"}, ...]`

## URLs de Documentación Swagger

FastAPI genera automáticamente la documentación de la API en formato OpenAPI/Swagger. Una vez que el servidor esté ejecutándose, puedes acceder a las siguientes URLs:

### Documentación Interactiva
- **Swagger UI**: `http://localhost:8000/docs`
  - Interfaz web interactiva para probar los endpoints
  - Permite ejecutar requests directamente desde el navegador
  - Muestra ejemplos de request/response

- **ReDoc**: `http://localhost:8000/redoc`
  - Documentación alternativa con un diseño más limpio
  - Mejor para lectura y referencia

### Archivo JSON de Documentación
- **OpenAPI Schema (JSON)**: `http://localhost:8000/openapi.json`
  - Esquema completo de la API en formato JSON
  - Útil para generar clientes automáticamente
  - Compatible con herramientas de testing como Postman

### Cómo Descargar el Archivo JSON

#### Opción 1: Desde el navegador
1. Ejecuta el servidor: `uvicorn main:app --reload`
2. Abre en el navegador: `http://localhost:8000/openapi.json`
3. Guarda el contenido como `api-docs.json`

#### Opción 2: Usando curl
```bash
curl -o api-docs.json http://localhost:8000/openapi.json
```

#### Opción 3: Usando wget
```bash
wget -O api-docs.json http://localhost:8000/openapi.json
```

#### Opción 4: Usando Python
```python
import requests
import json

response = requests.get('http://localhost:8000/openapi.json')
with open('api-docs.json', 'w', encoding='utf-8') as f:
    json.dump(response.json(), f, indent=2, ensure_ascii=False)
```

### Personalizar la Documentación

Puedes personalizar la documentación modificando el archivo `main.py`:

```python
from fastapi import FastAPI
from routers import users, posts, comments
from database import init_db

app = FastAPI(
    title="API de Blog",
    description="Una API RESTful para gestionar un blog con usuarios, publicaciones y comentarios",
    version="1.0.0",
    contact={
        "name": "Tu Nombre",
        "email": "tu.email@ejemplo.com",
    },
    license_info={
        "name": "MIT",
        "url": "https://opensource.org/licenses/MIT",
    },
)

# Inicializar la base de datos
init_db()

# Incluir los routers
app.include_router(users.router)
app.include_router(posts.router)
app.include_router(comments.router)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### Importar en Postman

1. Abre Postman
2. Haz clic en "Import"
3. Selecciona "Link" y pega: `http://localhost:8000/openapi.json`
4. O descarga el archivo JSON y súbelo directamente
5. Postman creará automáticamente una colección con todos los endpoints

## Notas
- La base de datos SQLite (`blog.db`) se crea automáticamente al iniciar la aplicación.
- Usa parámetros de query para `user_id` en las solicitudes POST, por ejemplo, `/posts/?user_id=1`.
- La API incluye manejo de errores para IDs de usuarios o publicaciones inválidos y nombres de usuario/correos duplicados.
- La documentación Swagger se actualiza automáticamente cuando modificas los endpoints o modelos.
- El archivo JSON generado es compatible con OpenAPI 3.0.