# üìò Tutorial Detallado, Extensivo y Completo de Pydantic en Espa√±ol

## 1. ¬øQu√© es Pydantic?

**Pydantic** es una biblioteca de validaci√≥n y configuraci√≥n de datos en tiempo de ejecuci√≥n para Python, basada en anotaciones de tipo (type hints). Es ampliamente utilizada en aplicaciones modernas de Python, especialmente con frameworks como **FastAPI**, **Starlette**, y **Django Ninja**.

### Caracter√≠sticas principales:
- Validaci√≥n autom√°tica de datos basada en tipos.
- Generaci√≥n de documentaci√≥n autom√°tica (como JSON Schema).
- Conversi√≥n autom√°tica de tipos (casting).
- Soporte para modelos anidados, listas, diccionarios, y m√°s.
- Integraci√≥n perfecta con herramientas de desarrollo (IDEs, mypy, etc.).
- Compatible con Python 3.7+ (y versiones m√°s recientes).

Pydantic ayuda a evitar errores comunes en la manipulaci√≥n de datos, especialmente en APIs, formularios, archivos de configuraci√≥n o bases de datos.

---

## 2. Instalaci√≥n y Requisitos

### Instalaci√≥n

```bash
pip install pydantic
```

Para Pydantic v2 (recomendado desde 2023):

```bash
pip install "pydantic>=2.0.0"
```

> ‚ö†Ô∏è **Nota**: Pydantic v2 fue lanzado en 2023 y trae cambios importantes. Este tutorial cubre principalmente v2, pero se indicar√°n diferencias con v1 cuando sea relevante.

### Requisitos
- Python 3.7 o superior
- Bibliotecas est√°ndar de Python

---

## 3. Modelos B√°sicos con `BaseModel`

La clase base de Pydantic es `BaseModel`. Define modelos de datos con campos tipados.

### Ejemplo b√°sico

```python
from pydantic import BaseModel

class Usuario(BaseModel):
    nombre: str
    edad: int
    email: str

# Crear una instancia
usuario = Usuario(nombre="Ana", edad=30, email="ana@example.com")

print(usuario)
# salida: nombre='Ana' edad=30 email='ana@example.com'
```

### ¬øQu√© hace Pydantic aqu√≠?
- Valida que `edad` sea un entero.
- Convierte tipos si es posible (ej. cadena `"30"` ‚Üí entero `30`).
- Lanza error si falta un campo obligatorio.

---

## 4. Validaci√≥n de Datos

Pydantic valida autom√°ticamente los tipos y valores al instanciar un modelo.

### Ejemplo de validaci√≥n

```python
from pydantic import BaseModel, ValidationError

class Producto(BaseModel):
    nombre: str
    precio: float
    disponible: bool

# Intento con datos inv√°lidos
try:
    p = Producto(nombre="Laptop", precio="abc", disponible="no")
except ValidationError as e:
    print(e)
```

**Salida:**
```
2 validation errors for Producto
precio
  Input should be a valid number [type=float_type, ...]
disponible
  Input should be a valid boolean [type=bool_type, ...]
```

---

## 5. Tipos de Datos Soportados

Pydantic soporta todos los tipos est√°ndar de Python y muchos adicionales del m√≥dulo `typing`.

### Tipos comunes

| Tipo | Descripci√≥n |
|------|-------------|
| `str` | Cadenas de texto |
| `int` | Enteros |
| `float` | N√∫meros decimales |
| `bool` | Booleanos (`True`/`False`) |
| `list` | Listas |
| `dict` | Diccionarios |
| `tuple` | Tuplas |
| `set` | Conjuntos |
| `datetime.datetime` | Fecha y hora |
| `datetime.date` | Solo fecha |
| `datetime.time` | Solo hora |
| `uuid.UUID` | Identificadores √∫nicos |

### Ejemplo con tipos complejos

```python
from datetime import datetime, date
from uuid import UUID
from typing import List
from pydantic import BaseModel

class Pedido(BaseModel):
    id: UUID
    fecha: datetime
    cliente: str
    productos: List[str]
    fecha_entrega: date
```

> ‚úÖ Pydantic puede convertir cadenas a `datetime`, `date`, `UUID`, etc., autom√°ticamente.

---

## 6. Campos Opcionales y Valores por Defecto

### Campos opcionales

Usa `Optional[]` o el operador `|` (Python 3.10+) con `None`.

```python
from typing import Optional
from pydantic import BaseModel

class Empleado(BaseModel):
    nombre: str
    edad: Optional[int] = None  # Opcional con valor por defecto None
    departamento: str = "General"  # Valor por defecto
```

### Uso

```python
emp1 = Empleado(nombre="Luis")  # edad=None, departamento="General"
emp2 = Empleado(nombre="Mar√≠a", edad=28, departamento="IT")
```

> üîπ En Pydantic v2, tambi√©n puedes usar `Annotated` con `Field(default=None)` para mayor control.

---

## 7. Campos Anotados con `Field`

`Field` permite a√±adir metadatos a los campos: valores por defecto, restricciones, descripciones, etc.

```python
from pydantic import BaseModel, Field
from typing import Optional

class Libro(BaseModel):
    titulo: str = Field(..., min_length=1, max_length=100, description="T√≠tulo del libro")
    autor: str = Field(..., min_length=2)
    paginas: int = Field(..., gt=0, le=10000)  # >0 y <=10000
    isbn: Optional[str] = Field(
        default=None,
        pattern=r"^\d{3}-\d{10}$",  # Ej: 978-1234567890
        description="ISBN en formato 13 d√≠gitos con gui√≥n"
    )
```

### Par√°metros comunes de `Field`:

| Par√°metro | Descripci√≥n |
|----------|-------------|
| `default` | Valor por defecto |
| `default_factory` | Funci√≥n que genera el valor por defecto |
| `...` (Ellipsis) | Indica que el campo es obligatorio |
| `min_length`, `max_length` | Longitud m√≠nima/m√°xima (para str, list) |
| `gt`, `ge`, `lt`, `le` | Mayor que, mayor o igual, menor que, menor o igual |
| `pattern` | Expresi√≥n regular |
| `description` | Descripci√≥n del campo |
| `examples` | Ejemplos de uso |

---

## 8. Validadores Personalizados

Puedes definir validadores usando decoradores `@field_validator` (v2) o `@validator` (v1).

### Validador de campo

```python
from pydantic import BaseModel, Field, field_validator
from typing import List

class Estudiante(BaseModel):
    nombre: str
    materias: List[str]
    promedio: float

    @field_validator('nombre')
    @classmethod
    def nombre_no_vacio(cls, v):
        if not v or v.strip() == "":
            raise ValueError('El nombre no puede estar vac√≠o')
        return v.strip()

    @field_validator('promedio')
    @classmethod
    def promedio_valido(cls, v):
        if v < 0 or v > 10:
            raise ValueError('El promedio debe estar entre 0 y 10')
        return v
```

### Validador de modelo completo

```python
from pydantic import BaseModel, model_validator

class Rectangulo(BaseModel):
    ancho: float
    alto: float
    area: float = None

    @model_validator(mode='after')
    def calcular_area(cls, model):
        model.area = model.ancho * model.alto
        return model
```

> üîπ `mode='after'`: se ejecuta despu√©s de la validaci√≥n de campos.  
> üîπ `mode='before'`: se ejecuta antes.

---

## 9. Modelos Anidados y Composici√≥n

Puedes usar modelos como tipos de campo.

```python
from pydantic import BaseModel
from typing import List

class Direccion(BaseModel):
    calle: str
    ciudad: str
    codigo_postal: str

class Persona(BaseModel):
    nombre: str
    direccion: Direccion
    telefonos: List[str] = []

# Uso
dir = Direccion(calle="Av. Siempre Viva 123", ciudad="Springfield", codigo_postal="12345")
persona = Persona(nombre="Homero", direccion=dir, telefonos=["555-1234"])

print(persona.direccion.ciudad)  # Springfield
```

---

## 10. Listas, Dicts y Colecciones

Pydantic soporta colecciones con validaci√≥n interna.

### Listas con tipo espec√≠fico

```python
from typing import List

class Inventario(BaseModel):
    productos: List[str]
    precios: List[float]
```

### Diccionarios

```python
from typing import Dict

class Configuracion(BaseModel):
    variables: Dict[str, str]  # claves y valores como str
```

### Listas de modelos

```python
class Tarea(BaseModel):
    titulo: str
    completada: bool

class ListaTareas(BaseModel):
    nombre: str
    tareas: List[Tarea]
```

---

## 11. Uso de Alias (Campos con Nombres Diferentes)

A veces los nombres de campo en Python no coinciden con los de JSON (ej: `user_id` vs `userId`).

### `alias` y `validation_alias`

```python
from pydantic import BaseModel, Field

class UsuarioAPI(BaseModel):
    usuario_id: int = Field(..., alias="userId")
    nombre_completo: str = Field(..., alias="fullName")

    class Config:
        populate_by_name = True  # Permite usar nombre de campo o alias
```

> üîπ En **Pydantic v2**, `populate_by_name` se llama `populate_by_name=True` en `model_config`.

### Uso con JSON

```python
json_data = '{"userId": 123, "fullName": "Ana P√©rez"}'
usuario = UsuarioAPI.model_validate_json(json_data)
print(usuario.usuario_id)  # 123
```

---

## 12. Serializaci√≥n y Deserializaci√≥n

### Deserializaci√≥n (de dict o JSON a modelo)

```python
data = {"nombre": "Carlos", "edad": 25, "email": "carlos@example.com"}
usuario = Usuario.model_validate(data)  # v2 (antes: parse_obj)
```

### Serializaci√≥n (modelo a dict o JSON)

```python
usuario_dict = usuario.model_dump()  # v2 (antes: dict())
usuario_json = usuario.model_dump_json(indent=2)
```

### Opciones comunes

```python
usuario.model_dump(
    include={'nombre', 'email'},  # Solo incluir estos campos
    exclude={'edad'},             # Excluir campo
    by_alias=True,                # Usar alias en salida
    exclude_none=True,            # No incluir valores None
)
```

---

## 13. Configuraci√≥n del Modelo (`Config`)

En Pydantic v2, se usa `model_config` como atributo de clase.

```python
from pydantic import BaseModel

class Producto(BaseModel):
    nombre: str
    precio: float

    model_config = {
        "frozen": True,                # Inmutabilidad
        "str_strip_whitespace": True,  # Eliminar espacios en str
        "validate_assignment": True,   # Validar al asignar
        "extra": "forbid",             # No permitir campos extra
    }
```

### Opciones clave de `model_config`:

| Opci√≥n | Descripci√≥n |
|-------|-------------|
| `frozen` | Hace el modelo inmutable (como un namedtuple) |
| `extra` | `'allow'`, `'ignore'`, `'forbid'` (campos no definidos) |
| `validate_assignment` | Valida al cambiar un atributo |
| `str_strip_whitespace` | Recorta espacios en cadenas |
| `arbitrary_types_allowed` | Permite tipos no est√°ndar (con precauci√≥n) |

---

## 14. Uso con FastAPI

Pydantic es el coraz√≥n de FastAPI para validaci√≥n de entrada/salida.

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

app = FastAPI()

class Item(BaseModel):
    nombre: str
    precio: float

class Pedido(BaseModel):
    id: int
    items: List[Item]
    activo: bool

@app.post("/pedidos/")
def crear_pedido(pedido: Pedido):
    return {"mensaje": "Pedido creado", "id": pedido.id}
```

FastAPI:
- Valida autom√°ticamente el JSON entrante.
- Genera documentaci√≥n OpenAPI (Swagger).
- Devuelve errores claros si falla la validaci√≥n.

---

## 15. Manejo de Errores y Excepciones

Pydantic lanza `ValidationError` cuando falla la validaci√≥n.

```python
from pydantic import ValidationError

try:
    modelo = MiModelo(**datos_invalidos)
except ValidationError as e:
    for error in e.errors():
        print(f"Error en campo {error['loc']}: {error['msg']}")
```

### Estructura de error

```json
[
  {
    "type": "missing",
    "loc": ["nombre"],
    "msg": "Field required",
    "input": {"edad": 25}
  }
]
```

---

## 16. Modelos Gen√©ricos

Puedes crear modelos reutilizables con tipos gen√©ricos.

```python
from typing import Generic, TypeVar, List
from pydantic import BaseModel

T = TypeVar('T')

class RespuestaPaginada(BaseModel, Generic[T]):
    items: List[T]
    total: int
    pagina: int
    hay_mas: bool

# Uso
class Usuario(BaseModel):
    id: int
    nombre: str

respuesta = RespuestaPaginada[Usuario](
    items=[Usuario(id=1, nombre="Ana")],
    total=1,
    pagina=1,
    hay_mas=False
)
```

---

## 17. Modelos Din√°micos y `create_model`

Crea modelos en tiempo de ejecuci√≥n.

```python
from pydantic import create_model

DynamicModel = create_model(
    'DynamicModel',
    nombre=(str, ...),
    edad=(int, Field(gt=0)),
    email=(str, None)
)

instancia = DynamicModel(nombre="Juan", edad=30)
```

√ötil para configuraciones din√°micas, APIs gen√©ricas, etc.

---

## 18. Uso con Pydantic v2 (Actualizaciones Clave)

Pydantic v2 (2023) trae cambios importantes:

### Cambios principales:

| v1 | v2 |
|----|----|
| `parse_obj()` | `model_validate()` |
| `dict()` | `model_dump()` |
| `json()` | `model_dump_json()` |
| `@validator` | `@field_validator` |
| `@root_validator` | `@model_validator(mode='before'/'after')` |
| `config` como clase | `model_config` como dict |

### Ejemplo v2

```python
from pydantic import BaseModel, field_validator, Field

class User(BaseModel):
    name: str = Field(..., min_length=2)
    age: int

    @field_validator('age')
    @classmethod
    def check_age(cls, v):
        if v < 0:
            raise ValueError('Age must be positive')
        return v

    model_config = {"extra": "forbid"}
```

---

## 19. Mejores Pr√°cticas y Consejos

1. ‚úÖ Usa `Field` para documentar y restringir campos.
2. ‚úÖ Define modelos peque√±os y reutilizables.
3. ‚úÖ Usa `model_config` para configurar comportamiento global.
4. ‚úÖ Evita l√≥gica compleja en validadores; mant√©nlos simples.
5. ‚úÖ Usa `default_factory` para valores mutables (listas, dict):

```python
from typing import List
from pydantic import BaseModel, Field

class Grupo(BaseModel):
    miembros: List[str] = Field(default_factory=list)
```

6. ‚úÖ Usa `exclude_none=True` al serializar para JSON limpio.
7. ‚úÖ Combina con `mypy` para detecci√≥n temprana de errores.

---

## 20. Ejemplo Completo: API REST con Pydantic + FastAPI

```python
# main.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel, Field, field_validator
from typing import List, Optional
from datetime import datetime

app = FastAPI(title="API de Tareas", version="1.0")

# Modelos
class TareaBase(BaseModel):
    titulo: str = Field(..., min_length=1, max_length=100)
    descripcion: Optional[str] = None

class TareaCrear(TareaBase):
    @field_validator('titulo')
    @classmethod
    def no_contiene_prohibido(cls, v):
        prohibidas = ["spam", "malware"]
        if any(p in v.lower() for p in prohibidas):
            raise ValueError("T√≠tulo no permitido")
        return v

class Tarea(TareaBase):
    id: int
    completada: bool = False
    fecha_creacion: datetime

    model_config = {"from_attributes": True}  # Para ORM

# Base de datos simulada
tareas_db = []
next_id = 1

@app.post("/tareas/", response_model=Tarea, status_code=201)
def crear_tarea(tarea: TareaCrear):
    global next_id
    nueva = Tarea(
        id=next_id,
        **tarea.model_dump(),
        fecha_creacion=datetime.now()
    )
    tareas_db.append(nueva)
    next_id += 1
    return nueva

@app.get("/tareas/", response_model=List[Tarea])
def listar_tareas():
    return tareas_db

@app.get("/tareas/{tarea_id}", response_model=Tarea)
def obtener_tarea(tarea_id: int):
    for t in tareas_db:
        if t.id == tarea_id:
            return t
    raise HTTPException(status_code=404, detail="Tarea no encontrada")
```

Inicia con:
```bash
uvicorn main:app --reload
```

Accede a:
- `http://localhost:8000/docs` ‚Üí Documentaci√≥n autom√°tica
- `http://localhost:8000/openapi.json` ‚Üí Esquema OpenAPI

---

